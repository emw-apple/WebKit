#!/usr/bin/env python3
# vim: set ft=python:
# -*- coding: utf-8 -*-
#
# Copyright (C) 2018 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


# Extract dependency information from the output of `make -d`, generating a
# list of top-level targets (which are assumed to be generated/output files)
# and a list of leaf dependencies (which are assumed to be the base input
# files). Read the make dependency information from stdin and write the results
# to the specified files.

from __future__ import print_function

import argparse
import re
import shlex
import sys

class Parser(object):

    fileNamePattern         = r"`([^']+)'"
    rePrerequisite          = re.compile(r"Prerequisite {} is .* than target {}".format(fileNamePattern, fileNamePattern))
    reMustRemakeTarget      = re.compile(r"Must remake target {}".format(fileNamePattern))
    reWasConsideredAlready  = re.compile(r"{} was considered already.".format(fileNamePattern))
    rePruningFile           = re.compile(r"Pruning file {}.".format(fileNamePattern))

    def __init__(self):
        self.targets = {}
        self.prereqs = {}
        self.graph = {}

    def nextLine(self, input):
        while True:
            line = input.readline()
            if not line: break
            line = line.strip()
            if line: yield line

    def addTarget(self, target):
        if target != 'all' and target != 'force':
            self.targets[target] = 1

    def addPrereq(self, prereq):
        if prereq != 'all' and prereq != 'force':
            self.prereqs[prereq] = 1
            
    def addEdge(self, target, prereq):
        if {target, prereq} & {'all', 'force'}:
            return
        prereqs = self.graph.setdefault(target, set())
        prereqs.add(prereq)
        
    def addNode(self, target):
        if target in ('all', 'force'):
            return
        self.graph.setdefault(target, set())

    def doParse(self, input):

        # Pull out everything that looks like a target or prerequisite.

        for line in self.nextLine(input):
            m = Parser.rePrerequisite.search(line)
            if m:
                self.addTarget(m.group(2))
                self.addPrereq(m.group(1))
                self.addEdge(m.group(2), m.group(1))
                continue

            m = Parser.reMustRemakeTarget.search(line)
            if m:
                self.addTarget(m.group(1))
                self.addNode(m.group(1))
                continue

            m = Parser.reWasConsideredAlready.search(line)
            if m:
                self.addTarget(m.group(1))
                self.addNode(m.group(1))
                continue

            m = Parser.rePruningFile.search(line)
            if m:
                self.addPrereq(m.group(1))
                continue

        # Regarding prerequisites, we're interested in only those that aren't
        # also targets. We only want ones that don't have build rules, and
        # hence must already exist. Those are our inputs.

        for key in self.targets.keys():
            self.prereqs.pop(key, None)

    def printInputs(self, inputsFile):
        with open(inputsFile, 'w') as toFile:
            [ print("{}".format(f), file = toFile) for f in sorted(self.prereqs.keys()) ]

    def printOutputs(self, outputsFile):
        with open(outputsFile, 'w') as toFile:
            [ print("{}".format(f), file = toFile) for f in sorted(self.targets.keys()) ]

    def printDepfile(self, depfile):
        assert sorted(self.graph.keys()) == sorted(self.targets.keys())
        # Use >=, not ==: The flat inputs and outputs mode discards intermediate dependencies
        # targets. The depfile mode doesn't, because it's not messy to write intermediate files to a
        # temporary location, and it allows devs to change intermediate files manually and still build.
        assert {p for ps in self.graph.values() for p in ps} >= self.prereqs.keys(), \
            "{} not a superset of {}".format(self.graph.values(), self.prereqs.keys())
        with open(depfile, 'w') as depfile:
            for target, prereqs in sorted(self.graph.items()):
                depfile.write(shlex.quote(target))
                depfile.write(':')
                for prereq in sorted(prereqs):
                    depfile.write(' \\\n    ')
                    depfile.write(shlex.quote(prereq))
                depfile.write('\n')


def parseArgs():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--input',
        metavar='<xcfilelist>',
        help='path to the xcfilelist holding input files')

    parser.add_argument(
        '--output',
        metavar='<xcfilelist>',
        help='path to the xcfilelist holding output/generated files')

    parser.add_argument(
        '--depfile',
        help='path to write a clang-style dependencies list to'
    )

    return parser.parse_args()


def main():
    args = parseArgs()
    parser = Parser()

    if not (args.input or args.output or args.depfile):
        parser.error("No output paths specified")

    parser.doParse(sys.stdin)
    if args.input:
        parser.printInputs(args.input)
    if args.output:
        parser.printOutputs(args.output)
    if args.depfile:
        parser.printDepfile(args.depfile)


if __name__ == '__main__':
    main()
